import {
  Client,
  GatewayIntentBits,
  Collection,
  TextChannel,
  Guild,
} from "discord.js";
import fs from "fs";
import path from "path";
import supabasePkg from "@supabase/supabase-js";
const { createClient } = supabasePkg;
import type { SupabaseClient } from "@supabase/supabase-js";

// --- CONFIGURATION ---

// --- TYPES ---
interface DiscordMessage {
  id: string;
  author: {
    id: string;
    username: string;
    discriminator: string;
    bot: boolean;
  };
  content: string;
  attachments: string[];
  timestamp: number;
  formattedTimestamp: string;
}

interface SupabaseMessage {
  from: string; // author username
  message: string; // content
  channel: string; // channel name
  // created_at is auto-generated by Supabase
  // id is auto-generated by Supabase
}

// --- HELPER FUNCTIONS ---
/**
 * Ensures the directory for storing messages exists.
 */
function ensureMessagesDirectoryExists(): void {
  if (!fs.existsSync(MESSAGES_DIR)) {
    fs.mkdirSync(MESSAGES_DIR, { recursive: true });
    console.log(`Created directory: ${MESSAGES_DIR}`);
  }
}

/**
 * Initializes and returns a Supabase client.
 * Exits if Supabase environment variables are not set.
 */
function initializeSupabaseClient(): SupabaseClient | null {
  if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
    console.error(
      "Supabase URL or Anon Key is not set in environment variables."
    );
    console.error("Please set SUPABASE_URL and SUPABASE_ANON_KEY.");
    process.exit(1);
    return null; // Should not reach here due to process.exit
  }
  try {
    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    console.log("Supabase client initialized.");
    return supabase;
  } catch (error) {
    console.error("Error initializing Supabase client:", error);
    process.exit(1);
    return null; // Should not reach here
  }
}

/**
 * Inserts messages into the Supabase table.
 * @param supabase - The Supabase client.
 * @param messages - Array of messages to insert.
 * @param channelName - The name of the channel these messages belong to.
 */
async function insertMessagesToSupabase(
  supabase: SupabaseClient,
  messages: DiscordMessage[],
  channelName: string
): Promise<void> {
  const messagesToInsert: SupabaseMessage[] = messages.map((msg) => ({
    from: msg.author.username,
    message: msg.content,
    channel: channelName,
  }));

  if (messagesToInsert.length === 0) {
    console.log(
      `No new messages from #${channelName} to insert into Supabase.`
    );
    return;
  }

  const { data, error } = await supabase
    .from("discord-messages") // Ensure this is your table name
    .insert(messagesToInsert);

  if (error) {
    console.error(
      `Error inserting messages from #${channelName} to Supabase:`,
      error
    );
  } else {
    console.log(
      `Successfully inserted ${messagesToInsert.length} messages from #${channelName} into Supabase.`
    );
  }
}

// --- MAIN LOGIC ---

/**
 * Fetches all messages from a given text channel, saves them to a JSON file,
 * and inserts them into Supabase.
 * @param channel - The TextChannel to fetch messages from.
 * @param supabase - The Supabase client.
 * @param guildName - The name of the guild (for logging).
 */
async function fetchAndProcessChannelMessages(
  channel: TextChannel,
  supabase: SupabaseClient,
  guildName: string
): Promise<void> {
  console.log(`Fetching messages from #${channel.name} in server ${guildName}`);

  let fetchedMessagesArray: DiscordMessage[] = [];
  let lastId: string | undefined;

  while (true) {
    const options: { limit: number; before?: string } = { limit: 100 };
    if (lastId) options.before = lastId;

    const fetchedMessagesBatch: Collection<string, any> = await channel.messages
      .fetch(options)
      .catch((error) => {
        console.error(`Error fetching messages in #${channel.name}:`, error);
        return new Collection<string, any>();
      });

    if (fetchedMessagesBatch.size === 0) break;

    const formattedMessages: DiscordMessage[] = Array.from(
      fetchedMessagesBatch.values()
    ).map((msg: any) => ({
      // Explicitly type msg as any here if its type is complex/unknown from discord.js
      id: msg.id,
      author: {
        id: msg.author.id,
        username: msg.author.username,
        discriminator: msg.author.discriminator,
        bot: msg.author.bot,
      },
      content: msg.content,
      attachments: Array.from(msg.attachments.values()).map(
        (att: any) => att.url
      ),
      timestamp: msg.createdTimestamp,
      formattedTimestamp: new Date(msg.createdTimestamp).toISOString(),
    }));

    fetchedMessagesArray = fetchedMessagesArray.concat(formattedMessages);
    lastId = fetchedMessagesBatch.last()?.id;

    console.log(
      `Fetched ${fetchedMessagesBatch.size} messages from #${channel.name}. Total for channel: ${fetchedMessagesArray.length}`
    );
    // Rate limiting: Consider adjusting or making this configurable if global rate limits are hit
    await new Promise((resolve) => setTimeout(resolve, 1000));
  }

  if (fetchedMessagesArray.length > 0) {
    // Save to individual JSON file
    const channelFileName = `${channel.name
      .replace(/[^a-z0-9]/gi, "_")
      .toLowerCase()}.json`;
    const filePath = path.join(MESSAGES_DIR, channelFileName);
    fs.writeFileSync(filePath, JSON.stringify(fetchedMessagesArray, null, 2));
    console.log(
      `Saved ${fetchedMessagesArray.length} messages from #${channel.name} to ${filePath}`
    );

    // Insert into Supabase
    await insertMessagesToSupabase(
      supabase,
      fetchedMessagesArray,
      channel.name
    );
  } else {
    console.log(`No messages found or fetched for #${channel.name}.`);
  }
}

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
  ],
});

client.once("ready", async () => {
  if (!client.user) {
    console.error("Client user is not available.");
    process.exit(1);
    return;
  }
  console.log(`Logged in as ${client.user.tag}`);

  ensureMessagesDirectoryExists();
  const supabase = initializeSupabaseClient();
  if (!supabase) return; // Exit if Supabase client failed to initialize

  try {
    const guild: Guild | undefined = client.guilds.cache.first();
    if (!guild) {
      console.error("Bot is not in any guilds.");
      process.exit(1);
      return;
    }
    console.log(`Fetching messages from server: ${guild.name}`);

    const textChannels = guild.channels.cache.filter(
      (channel): channel is TextChannel => channel.type === 0 // 0 is GUILD_TEXT
    );

    console.log(`Found ${textChannels.size} text channels.`);

    // Process all channels in parallel
    const channelProcessingPromises = Array.from(textChannels.values()).map(
      (channel) => fetchAndProcessChannelMessages(channel, supabase, guild.name)
    );

    await Promise.all(channelProcessingPromises);

    console.log(
      "All messages have been fetched, saved to individual files, and attempted to be saved to Supabase!"
    );
    process.exit(0);
  } catch (error) {
    console.error("An error occurred during the main process:", error);
    process.exit(1);
  }
});

client.login(TOKEN);
